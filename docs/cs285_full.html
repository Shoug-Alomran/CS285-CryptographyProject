<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CS285 - Diffie-Hellman Key Exchange Implementation</title>
    <style>
        :root {
            --primary: #4a6baf;
            --secondary: #8a4db9;
            --accent: #6c5ce7;
            --light: #f8f9fa;
            --dark: #343a40;
            --success: #28a745;
            --warning: #ffc107;
            --danger: #dc3545;
            --info: #17a2b8;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            background-attachment: fixed;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .report {
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            padding: 40px;
            margin-bottom: 30px;
        }
        
        header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 1px solid #eee;
        }
        
        h1 {
            color: var(--primary);
            margin-bottom: 10px;
            font-size: 2.2rem;
        }
        
        .course-info {
            color: var(--dark);
            margin-bottom: 20px;
        }
        
        .contributors {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }
        
        .contributor {
            background: #f1f3f9;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
        }
        
        .toc {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin: 30px 0;
        }
        
        .toc h2 {
            margin-bottom: 15px;
            color: var(--primary);
        }
        
        .toc ol {
            margin-left: 20px;
        }
        
        .toc li {
            margin-bottom: 8px;
        }
        
        .toc a {
            color: var(--secondary);
            text-decoration: none;
        }
        
        .toc a:hover {
            text-decoration: underline;
        }
        
        .section {
            margin-bottom: 40px;
        }
        
        .section-header {
            background: linear-gradient(to right, var(--primary), var(--secondary));
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
        }
        
        .section-header i {
            margin-right: 10px;
            font-size: 1.2rem;
        }
        
        h2 {
            color: var(--primary);
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 1px solid #eee;
        }
        
        h3 {
            color: var(--secondary);
            margin: 20px 0 10px;
        }
        
        p {
            margin-bottom: 15px;
        }
        
        .image-container {
            margin: 20px 0;
            text-align: center;
        }
        
        .screenshot {
            max-width: 100%;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        
        .caption {
            background: #f1f3f9;
            padding: 8px 15px;
            border-radius: 4px;
            font-style: italic;
            margin-top: 10px;
            display: inline-block;
        }
        
        .code-block {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
        }
        
        .code-comment {
            color: #75715e;
        }
        
        .code-keyword {
            color: #f92672;
        }
        
        .code-string {
            color: #e6db74;
        }
        
        .code-function {
            color: #a6e22e;
        }
        
        .code-class {
            color: #66d9ef;
        }
        
        .team-contribution {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .member {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid var(--primary);
        }
        
        .member h4 {
            color: var(--primary);
            margin-bottom: 10px;
        }
        
        .references {
            list-style-type: none;
        }
        
        .references li {
            margin-bottom: 15px;
            padding-left: 20px;
            text-indent: -20px;
        }
        
        footer {
            text-align: center;
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #eee;
            color: #6c757d;
            font-size: 0.9rem;
        }
        
        @media (max-width: 768px) {
            .report {
                padding: 20px;
            }
            
            .team-contribution {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="report">
            <header>
                <h1>Implementation and Analysis of the Diffie–Hellman Key Exchange Algorithm in Java</h1>
                <div class="course-info">
                    <p><strong>CS285: Discrete Mathematics for Computing</strong></p>
                    <p><strong>Course Instructor:</strong> Dr. Jalila Zouhair</p>
                    <p><strong>Section #:</strong> 963</p>
                </div>
                <div class="contributors">
                    <div class="contributor">SHOUG FAWAZ ABDULLAH ALOMRAN 223410392</div>
                    <div class="contributor">ALJOHARA WALEED A ALBAWARDI 223410346</div>
                    <div class="contributor">YARA MUTLAQ MOHAMMED ALZAMEL 223410834</div>
                    <div class="contributor">FAI MOHAMMAD BIN KHANJAR 223410071</div>
                </div>
            </header>
            
            <div class="toc">
                <h2>Table of Contents</h2>
                <ol>
                    <li><a href="#introduction">Introduction</a>
                        <ol>
                            <li><a href="#purpose">Purpose of the Diffie–Hellman Key Exchange and Its Applications</a></li>
                            <li><a href="#algorithm">Algorithm Explanation</a></li>
                            <li><a href="#numerical">Numerical Example</a></li>
                            <li><a href="#advantages">Advantages & Limitations</a></li>
                            <li><a href="#comparison">Comparison</a></li>
                        </ol>
                    </li>
                    <li><a href="#code">Code Description</a>
                        <ol>
                            <li><a href="#program">How the Program Works</a></li>
                            <li><a href="#implementation">Implementation of Each Part</a></li>
                            <li><a href="#challenges">Challenges Faced and How We Overcame Them</a></li>
                        </ol>
                    </li>
                    <li><a href="#results">Results and Test Cases</a></li>
                    <li><a href="#team">Team Contribution</a></li>
                    <li><a href="#conclusion">Conclusion</a></li>
                    <li><a href="#references">References and Resources</a></li>
                    <li><a href="#appendix">Appendix – Full Source Code</a></li>
                </ol>
            </div>
            
            <div class="section" id="introduction">
                <div class="section-header">
                    <h2>1. Introduction</h2>
                </div>
                
                <p>In today's digital world, secure communication is the need of the hour to protect sensitive information being exchanged over public networks. The Diffie-Hellman key exchange algorithm allows two parties to agree on a shared secret key without actually exchanging it, and forms a basis for many of today's encryption schemes.</p>
                
                <p>The following Java code for the Diffie–Hellman implementation is provided for CS285, Discrete Mathematics for Computing. The developed system incorporates some of the very fundamental mathematical concepts regarding modular arithmetic and exponentiation. The system simulates secure key generation and exchange between two entities using the Diffie–Hellman key exchange method. A simple encryption and decryption mechanism has also been provided to illustrate how the derived shared key can be used to secure messages.</p>
                
                <p>We divide the program into the following classes: Parameters handles all public values, KeyExchange generates and computes keys, Encryptor encrypts messages, and Validator, Helpers, and Utils ensure correct input handling and output formatting. The Main class integrates all components of the system and allows users to test both a predefined numerical example and a live interactive mode.</p>
                
                <p>The project ties together theoretical mathematics and programming in practice, showing how secure key exchange and encryption work in real-world systems.</p>
                
                <h3 id="purpose">1.1 Purpose of the Diffie–Hellman Key Exchange and Its Applications</h3>
                
                <p>The Diffie-Hellman key exchange is a cryptography technique whose main purpose is to allow two parties to exchange a key that can be used for encrypting messages. This shared key can be used in public channels that ensures no one unauthorized can read it. The key concept was developed by Ralph Merkle but was published by Whitfield Diffie and Martin Hellman in 1976, which is why it's named after them.</p>
                
                <p>The Diffie-Hellman key exchange is used in many ways in real life for example its use in Transport Layer Security (TLS). TLS uses a set of protocols to establish a secure tunnel for web traffic. During the initial "handshake" process, the browser authenticates the server's TLS certificate to verify its identity. Once both parties are authenticated, they use a Diffie-Hellman (DH) variant to exchange public values and generate a unique session key. This key encrypts all data transmitted throughout the browsing session, ensuring that sensitive information such as passwords and credit card numbers remains protected (Ambatipudi, 2024).</p>
                
                <p>Another use is Secure Shell commonly known as SSH. This network protocol is used for securely logging into and controlling remote computers, as well as transferring files. SSH uses the DH algorithm early in the connection process to establish a secret key between the client and the server, ensuring that all subsequent commands, outputs, and file transfers are encrypted and protected from interception (Ambatipudi, 2024).</p>
                
                <h3 id="algorithm">1.2 Algorithm Explanation</h3>
                
                <p>The Diffie–Hellman key exchange algorithm allows two people known as Alice and Bob to create a secret key and send it over insecure channels such as the Internet. To generate matching secret keys, the Diffie–Hellman method uses modular arithmetic and exponentiation, in which both users perform calculations using a shared set of public numbers. Without knowing the private numbers, this process is almost impossible to reverse, but it is simple to compute in one direction.</p>
                
                <p>First, a primitive root α and a large prime number q are publicly agreed upon by both Alice and Bob. Everyone can know these two values; they are not hidden. After that, Alice chose an integer Xa, and Bob chose an integer Xb; both integers should be less than q and kept private.</p>
                
                <p>The third step is by generating their public keys as Ya = α[Xa] mod q and Yb = α[Xb] mod q. Both Alice and Bob can now exchange their public keys using the network. Now, using modular arithmetic once more, each user raises the received public key to the power of their own private key in order to obtain the shared secret. Alice calculates k = Yb[Xa] mod q, while Bob calculates k = Ya[Xb] mod q; this will result in the same secret key.</p>
                
                <p>Even though the values q, α, Ya, and Yb are publicly available, it is nearly impossible to deduce the private keys Xa or Xb from them, which is what gives the Diffie–Hellman algorithm its security. This complexity is due to the fact that it is very challenging to solve the discrete logarithm problem, which is the task of determining the exponent used in modular arithmetic, for large numbers (Diffie & Hellman, 1976; Roy, Datta & Mitchell, 2007).</p>
                
                <p>During a royal convoy, vehicles and the control center must communicate on location and security instructions. Each vehicle and the control center first reach an agreement on some public integers. Then they create their own private keys and calculate the public keys from them. After sending the public keys to each other, both sides use the Diffie–Hellman method, specifically the Elliptic Curve version (ECDH), to arrive at the same secret key. This key helps maintain the security of the messages. Even if someone is able to intercept the data, they won't be able to decode the messages or determine exactly which route taken by the convoy. Section 1.3 provides an easy explanation of how this is implemented.</p>
                
                <h3 id="numerical">1.3 Numerical Example</h3>
                
                <p>To give an example, both 2 cars and the control center need a safe way to communicate during the royal convoy.</p>
                
                <ol>
                    <li>Everyone agrees on two public numbers: q = 23 and a = 5.</li>
                    <li>The first car chooses a private number Xa = 6 and calculates its public key Ya = a^Xa mod q = 5^6 mod 23 = 8.</li>
                    <li>Car 2 chooses a private number Xb = 15 and calculates its public key Yb = a^Xb mod q = 5^15 mod 23 = 19.</li>
                    <li>They exchange their public keys Ya and Yb.</li>
                    <li>Each car calculates the shared secret key:
                        <ul>
                            <li>Car 1 computes Yb^Xa mod q = 19^6 mod 23 = 2.</li>
                            <li>Car 2 computes Ya^Xb mod q = 8^15 mod 23 = 2.</li>
                        </ul>
                    </li>
                    <li>Both cars get the same secret key 2, which keeps their messages safe so no one can read them.</li>
                </ol>
                
                <div class="image-container">
                    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAABkCAYAAAAX5r5+AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAOxAAADsQBlSsOGwAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAA" class="screenshot" alt="Numerical Example (Fixed Values)">
                    <div class="caption">Numerical Example (Section 1.3 – Fixed)</div>
                </div>
                
                <div class="image-container">
                    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAABkCAYAAAAX5r5+AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAOxAAADsQBlSsOGwAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAA" class="screenshot" alt="Numerical Example (Auto-generated Values)">
                    <div class="caption">Numerical Example (Auto-generated values)</div>
                </div>
                
                <h3 id="advantages">1.4 Advantages & Limitations</h3>
                
                <p>The Diffie-Hellman (DH) key exchange is a quite ancient public-key cryptography scheme, in which two individuals desiring to derive a mutual secret key over an insecure line of communication agree. Its security relies upon the solvability of the discrete logarithmic problem (DLP). Mathematical problem whose solution becomes effectively impossible to achieve employing very large prime numbers (RubinStein-Salzedo 101).</p>
                
                <p>One of the reasons that Diffie-Hellman is most useful is that it offers secure key generation without needing an advanced key exchange. Both sides create a public and private value, and even if the attacker gets the public information, they cannot calculate the private key because of the hardness of DLP (RubinStein-Salzedo 104). This makes Diffie-Hellman a foundation for secure communication, especially where advance trust or physical key exchange is not feasible.</p>
                
                <p>Another key advantage is that DH can be designed to provide forward secrecy in case of correct usage. Forward secrecy ensures that even if a long-term private key is broken, previous messages encrypted with it are still secure. Adrian et al. refer to this element as the one that works towards limiting the effects of security violations and ensuring long-term confidentiality of computer systems (Adrian et al. 41). Diffie-Hellman is also great in theory and easy to implement, and this has set the standard for other secure protocols. Odlyzko records that application of modular arithmetic and exponentiation in the algorithm are well-chosen parameters to provide theoretical security (Odlyzko 3).</p>
                
                <p>Although being robust, the Diffie-Hellman algorithm has several frailties that must be addressed to deploy it safely. Its vulnerability to man-in-the-middle (MitM) attacks is the first among them. As the original protocol is not authenticating the user, there is an opportunity for the attacker to intercept messages, impersonating both parties, and generate two different shared keys, which enables them to read or alter all the communications (Rubinstein-Salzedo 109). Because authentication has not been applied, the system assumes both parties' public key is legitimate, which can be tampered with.</p>
                
                <p>Parameter reuse and incorrect configuration are another vulnerability. Adrian et al. have learned that the majority of real-world systems reuse one set of primes on several servers, making it simpler to attack them if one set gets into the wrong hands (Adrian et al. 42). Reusing weak or common primes diminishes general security because an adversary can precompute solutions for those specific values.</p>
                
                <p>Finally, DH is slower computationally than symmetric-key algorithms. Odlyzko explains that big primes require significant processing power, especially on small machines or low-end machines (Odlyzko 7). There must be a proper balance of the performance/security trade-off in order to realize practicability in implementations.</p>
                
                <h3 id="comparison">1.5 Comparison</h3>
                
                <p>The original Diffie-Hellman (DH) scheme rests on the pillars of arithmetic and the discrete logarithm problem, which together hand it a mathematically sound foundation for swapping keys securely. Still as we pointed out earlier its robustness leans heavily on the development of primes and the careful tuning of its parameters. Toss in primes or recycle the parameters over and over and the whole construction becomes open to sub-exponential and pre-computation attacks - adversaries can tease out the private keys by playing with the publicly shared values. Beyond that Diffie-Hellman can fall prey to man-in-the-middle attacks when authentication is omitted. Such shortcomings curb its efficiency and make it hard to scale for systems that demand both speed and robust security.</p>
                
                <p>Elliptic Curve Diffie-Hellman (ECDH) avoids many of the shortcomings by relying on elliptic-curve mathematics instead of modular arithmetic (Boneh & Shparlinski, 2001; Haakegaard & Lang, 2015). Since the elliptic-curve discrete logarithm problem (ECDLP) is far tougher to solve, ECDH can provide security with smaller keys - for example, a 256-bit ECDH key offers roughly the same strength as a 3072-bit DH key.</p>
                
                <p>Unlike Diffe-Hellman, which can be weakened when many users share the parameters, elliptic-curve Diffie-Hellman (ECDH) lets each party pick its own curve settings, thereby slashing the threat of large-scale pre-computation attacks. It also brings secrecy and unpredictability to the bits - knowing a slice of the key offers no edge to an attacker (Boneh & Shparlinski, 2001). Though ECDH adds some complexity, it has been widely embraced in cryptographic protocols such as TLS 1.3 and SSH, striking a sweet spot between performance and strong security.</p>
                
                <p>In summary, both DH and elliptic-curve share a common foundation yet differ significantly in design and efficiency. ECDH rests on the discrete-logarithm problem, it's practical and is secure. It preserves DH's strengths while delivering faster performance, smaller keys, and stronger resistance to known attacks.</p>
                
                <div class="image-container">
                    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAABkCAYAAAAX5r5+AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAOxAAADsQBlSsOGwAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAA" class="screenshot" alt="Venn Diagram comparing DH and ECDH">
                    <div class="caption">Venn Diagram comparing DH and ECDH</div>
                </div>
            </div>
            
            <div class="section" id="code">
                <div class="section-header">
                    <h2>2. Code Description</h2>
                </div>
                
                <h3 id="program">2.1 How the Program Works</h3>
                
                <p>For our program, we implemented a main program which tests all of our implementations, supported by six classes. Each class had a distinct rule, the parameters class stores and displayed our public parameters which included the prime number and primitive root. The key exchange class generated private and public keys and computed a shared secret key. We also had an encryptor class which handled encrypting and decrypting messages that used the shared key. Additionally, a validator class which performs for prime checks and making sure our message length is the right length. A utilities class was implemented with the main goal of making our program run better, it had helper methods such as random generation and formatted output.</p>
                
                <p>Finally, we have the helpers class which manages all our user inputs and ensures correctness such as message validation loops.</p>
                
                <h3 id="implementation">2.2 Implementation of Each Part</h3>
                
                <h4>Key Generation</h4>
                
                <div class="code-block">
                    <pre><code><span class="code-keyword">private void</span> <span class="code-function">generateKeys</span>() {
  <span class="code-keyword">this</span>.privateKey = <span class="code-keyword">new</span> BigInteger(getQ().bitLength(), random).mod(getQ().subtract(BigInteger.TWO))
    .add(BigInteger.ONE);  <span class="code-comment">// 1 <= x <= q-2</span>
  <span class="code-keyword">this</span>.publicKey = getAlpha().modPow(privateKey, getQ());
  <span class="code-comment">// Y = a^x mod q</span>
}</code></pre>
                </div>
                
                <p>To generate a private key, we would choose a random number from 1 to the prime number (q) minus 2. Then we find the public key (y) using the formula Y = a^x mod q.</p>
                
                <h4>Encryption</h4>
                
                <div class="code-block">
                    <pre><code><span class="code-keyword">String</span> <span class="code-function">encrypt</span>(<span class="code-keyword">String</span> msg, BigInteger sharedKey) <span class="code-keyword">throws</span> Exception {
  <span class="code-keyword">byte</span>[] msgByte = msg.getBytes(StandardCharsets.UTF_8); <span class="code-comment">// converts the text into bytes</span>
  <span class="code-keyword">byte</span>[] keyByte = Key(sharedKey); <span class="code-comment">// uses the key function to store the data</span>
  <span class="code-keyword">byte</span>[] cipherMsgByte = xor(msgByte, keyByte); <span class="code-comment">// ciphers the text</span>
  <span class="code-keyword">return</span> Base64.getEncoder().encoderToString(cipherMsgByte);
}</code></pre>
                </div>
                
                <p>To encrypt the message, we convert the message into Byte using the getBytes function, storing each byte in the array. Next, we use the Key method to convert the shared key to a byte then hashing the key, converting it into SHA-256, making it more difficult to decrypt. Lastly we cipher the message using the xor function which decrypts the bytes using the public key formula. This then can be printed in the main giving us multiple random letters that aren't readable.</p>
                
                <h4>Decryption</h4>
                
                <div class="code-block">
                    <pre><code><span class="code-keyword">String</span> <span class="code-function">decrypt</span>(<span class="code-keyword">String</span> base64cipherMsg, BigInteger sharedKey) <span class="code-keyword">throws</span> Exception {
  <span class="code-keyword">byte</span>[] keyByte = Key(sharedKey); <span class="code-comment">// stores data</span>
  <span class="code-keyword">byte</span>[] cipherMsgByte = Base64.getDecoder().decode(base64cipherMsg); <span class="code-comment">// decodes the data using a method</span>
  <span class="code-keyword">byte</span>[] msgByte = xor(cipherMsgByte, keyByte); <span class="code-comment">// uses the same equation to return it to a readable text</span>
  <span class="code-keyword">return</span> <span class="code-keyword">new</span> String(msgByte, StandardCharsets.UTF_8);
}</code></pre>
                </div>
                
                <p>For decryption, it's similar to encryption with a few differences. It starts with the Key method, hashing and organizing the bytes first then decoding the message using the getDecoder() function. Lastly it uses the xor again to return it into readable texts.</p>
                
                <h3 id="challenges">2.3 Challenges Faced and How We Overcame Them</h3>
                
                <p>In the process of testing and development, a lot of problems were encountered, particularly in input checking, class integration, and modular arithmetic operations. The most frequent problem was with initial testing of the validator and Main classes, where invalid user input, such as non-prime input numbers or message lengths less than 20 characters, at one point caused the program to crash. This was done by adding relentless loops of verification that will repeatedly ask the user instead of terminating execution, ensuring the program will be executed successfully regardless of wrong inputs.</p>
                
                <p>The second issue occurred while combining different team members' classes. Because every class (like Parameters, KeyExchange, and Encryptor) was programmed separately, variable names and method types needed to be standardized in a way that the Main class would compile and execute as needed. To avoid this, the team standardized method names such as generatePublicKey() and computeSharedKey() and inserted temporary placeholders in Main until they were finished writing all classes so it would be simple to insert later.</p>
                
                <p>Besides, preliminary tests were producing incorrect values in mathematical calculations for the public and common keys. This was due to the absence of modular exponentiation logic. Using Java's native modPow() method into the keyExchange class fixed this issue, delivering correct keys that matched both vehicles exactly.</p>
                
                <p>Finally, it was even attempted that encryption was exposing contradictions between the encrypted and decrypted messages due to discrepancies in how byte arrays were being handled. Altering the Encryptor class to use StandardCharsets.UTF_8 and Base64 encoding ensured all messages decrypted flawlessly into its original text.</p>
                
                <p>By overall systematic testing of all components, addition of good validation, and standardized naming conventions coordination, the team managed to get beyond integration as well as logic flaws and produce a functional implementation of the Diffie-Hellman key exchange system.</p>
            </div>
            
            <div class="section" id="results">
                <div class="section-header">
                    <h2>3. Results and Test Cases</h2>
                </div>
                
                <h3>Successful run with matching shared keys and valid messages</h3>
                
                <h4>Autogenerated keys</h4>
                
                <div class="image-container">
                    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAABkCAYAAAAX5r5+AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAOxAAADsQBlSsOGwAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAA" class="screenshot" alt="Live Mode - Autogenerated">
                    <div class="caption">Live Mode - Autogenerated</div>
                </div>
                
                <h4>Manual Keys</h4>
                
                <div class="image-container">
                    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAABkCAYAAAAX5r5+AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAOxAAADsQBlSsOGwAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAA" class="screenshot" alt="Live Mode - Manual">
                    <div class="caption">Live Mode - Manual</div>
                </div>
                
                <h4>Invalid prime q & alpha</h4>
                
                <div class="image-container">
                    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAABkCAYAAAAX5r5+AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAOxAAADsQBlSsOGwAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAA" class="screenshot" alt="Live Mode - Prime Error">
                    <div class="caption">Live Mode - Prime Error</div>
                </div>
                
                <div class="image-container">
                    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAABkCAYAAAAX5r5+AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAOxAAADsQBlSsOGwAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAA" class="screenshot" alt="Live Mode - Alpha Error">
                    <div class="caption">Live Mode - Alpha Error</div>
                </div>
                
                <h4>Short message (< 20 chars) validation error</h4>
                
                <div class="image-container">
                    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAABkCAYAAAAX5r5+AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAOxAAADsQBlSsOGwAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAA" class="screenshot" alt="Live Mode - Message Error">
                    <div class="caption">Live Mode - Message Error</div>
                </div>
            </div>
            
            <div class="section" id="team">
                <div class="section-header">
                    <h2>4. Team Contribution</h2>
                </div>
                
                <p>It was a collaborative project that required everyone to coordinate, communicate, and work together. All members of the group collaborated on both the Java implementation and the report, allowing for simultaneous technical and theoretical progress.</p>
                
                <div class="team-contribution">
                    <div class="member">
                        <h4>Yara Alzamel</h4>
                        <p>Yara Alzamel established the foundation of the program by declaring the public parameters and helper methods upon which the rest of the system depended. She was responsible for designing the classes that are responsible for the generation of the public values, i.e., the prime number and primitive root, and adding helper functions for normalizing random number generation and formatted print. She was responsible for the foundation on which the rest of the program was constructed and also to describe the program's initialization and overall flow in the report.</p>
                    </div>
                    
                    <div class="member">
                        <h4>Fai Bin Khanjar</h4>
                        <p>Fai Bin Khanjar took care of the underlying mathematics of implementing the Diffie–Hellman algorithm. She implemented key generation with private keys on both sides, calculated their corresponding public keys, and made sure that the resulting shared secret key generated was identical on both sides. She created a numerical example based on the report to explain step-by-step algorithm calculation. Her attentiveness during modular arithmetic verification and accuracy result checks helped to ensure the program's correctness.</p>
                    </div>
                    
                    <div class="member">
                        <h4>Aljohara Albawardi</h4>
                        <p>Aljohara Albawardi developed the encryption and decryption components of the project. She implemented a lightweight encryption mechanism that used the shared secret key derived from Fai's module. Her focus was on converting theoretical key exchange into practical message security, ensuring that messages longer than twenty characters could be securely encrypted and successfully decrypted. She also conducted test runs, captured the output by taking screenshots, and mentioned security advantages and restrictions of the algorithm in the report.</p>
                    </div>
                    
                    <div class="member">
                        <h4>Shoug Alomran</h4>
                        <p>Shoug Alomran executed validation, integration, and assembly of the program last. She used input validation to ensure that users enter a valid prime number and that the size of the message complies with project requirements. She applied all modules—key generation, key exchange, encryption, and output formatting—inside the driver program, tested the whole program running, and managed exceptions so that the program ran flawlessly end to end. Apart from her technical contribution, she also integrated the group's written elements into the final report, maintaining the structure, tone, and format intact.</p>
                    </div>
                </div>
                
                <p>The team achieved coordination primarily by using GitHub as a version manager and code shar