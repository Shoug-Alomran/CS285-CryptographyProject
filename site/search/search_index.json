{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CS285 \u2013 Secure Key Exchange Project","text":""},{"location":"#prince-sultan-university","title":"Prince Sultan University","text":"<p>Course: CS285 \u2013 Discrete Mathematics for Computing Project Title: Secure Key Exchange System (Diffie\u2013Hellman Demonstration) Instructor: Dr. Jalila Zouhair Submission Date: 9 November 2025  </p> <p>Developed by: - Shoug Fawaz Alomran - Fai Mohammad Khanjar - Aljohara Waleed Albawardi - Yara Mutlaq Alzamel  </p>"},{"location":"#abstract","title":"Abstract","text":"<p>This project demonstrates how two entities can securely establish a shared secret key using public-key cryptography principles. The implemented system applies the Diffie\u2013Hellman key exchange algorithm, which enables the participants to exchange information over an insecure channel without directly transmitting any secret values.  </p> <p>The resulting shared secret key can then be used to encrypt and decrypt messages, ensuring data confidentiality and integrity. This simulation also includes input validation, error handling, and the ability to operate in two modes: a numerical example (for demonstration) and a live mode (for user interaction).</p>"},{"location":"#objectives","title":"Objectives","text":"<ul> <li>Understand the mathematical foundation behind public-key cryptography.  </li> <li>Implement the Diffie\u2013Hellman algorithm in Java.  </li> <li>Validate that both participants compute the same shared secret key.  </li> <li>Use the shared key to encrypt and decrypt messages.  </li> <li>Apply input validation and robust error handling.  </li> <li>Document the algorithm, code, and results according to the official project format.</li> </ul> <p>Key Idea</p> <p>The security of the Diffie\u2013Hellman exchange depends on the difficulty of solving the discrete logarithm problem, making it practically impossible for an attacker to derive the private keys from the public information.</p>"},{"location":"about/","title":"About the Project","text":"<p>The Secure Key Exchange System was developed as part of the CS285 \u2013 Discrete Mathematics for Computing course at Prince Sultan University.</p> <p>This website presents the full report, source code, and implementation details of the project. It demonstrates how two participants can securely establish a shared secret key using the Diffie\u2013Hellman key exchange algorithm, implemented entirely in Java.</p>"},{"location":"about/#purpose-of-the-project","title":"Purpose of the Project","text":"<p>The project\u2019s objective is to: 1. Apply mathematical concepts of modular arithmetic and discrete logarithms. 2. Demonstrate secure key exchange using the Diffie\u2013Hellman algorithm. 3. Illustrate how the shared key enables message encryption and decryption. 4. Reinforce understanding of public-key cryptography fundamentals.</p> <p>Educational Goal</p> <p>This project serves as both a learning tool and a proof-of-concept, bridging the gap between mathematical theory and secure software implementation.</p>"},{"location":"advantages-limitations/","title":"Advantages &amp; Limitations","text":"<p>The Diffie\u2013Hellman (DH) key exchange algorithm enables two parties to establish a common secret key over an insecure channel without sharing any private information. While it remains one of the most foundational methods in cryptography, it also presents certain practical limitations that must be addressed when implemented in real systems.</p>"},{"location":"advantages-limitations/#advantages","title":"Advantages","text":"<ol> <li> <p>No Pre-shared Secret Required    Diffie\u2013Hellman allows two users to generate a shared secret key without any prior secure communication channel.    This makes it ideal for initiating secure sessions between previously unknown parties.</p> </li> <li> <p>Forward Secrecy    Even if a participant\u2019s long-term private key is compromised, past communication remains secure because each session key is independently generated.</p> </li> <li> <p>Strong Mathematical Foundation    The algorithm\u2019s security is based on the discrete logarithm problem (DLP), which is computationally infeasible to solve for large prime numbers.</p> </li> <li> <p>Wide Adoption    Diffie\u2013Hellman is used in numerous secure communication protocols, including TLS, SSH, and IPsec, forming the backbone of modern network security.</p> </li> </ol> <p>In Practice</p> <p>The use of large prime numbers and unique session keys makes Diffie\u2013Hellman a reliable choice for ensuring confidentiality during initial key negotiation.</p>"},{"location":"advantages-limitations/#limitations","title":"Limitations","text":"<ol> <li> <p>Man-in-the-Middle (MitM) Vulnerability    The algorithm alone does not authenticate users.    An attacker can intercept and replace public keys, tricking each participant into sharing a key with the attacker instead.</p> </li> <li> <p>Parameter Reuse Risk    If the same prime ( q ) and primitive root ( \\alpha ) are reused across multiple sessions, attackers may exploit weaknesses to reduce security.</p> </li> <li> <p>Computational Cost    The modular exponentiation involved in DH requires significant processing power for very large primes compared to symmetric encryption methods.</p> </li> <li> <p>No Built-in Authentication    DH must be combined with authentication mechanisms such as digital signatures or certificates to ensure both parties\u2019 identities are verified.</p> </li> </ol> <p>Security Note</p> <p>In practice, DH should always be paired with an authentication layer \u2014 for example, authenticated Diffie\u2013Hellman (DHA) or ECDHE \u2014 to prevent active attacks.</p>"},{"location":"advantages-limitations/#diffiehellman-vs-elliptic-curve-diffiehellman-ecdh","title":"Diffie\u2013Hellman vs Elliptic Curve Diffie\u2013Hellman (ECDH)","text":"Aspect DH ECDH Mathematical Basis Modular exponentiation Elliptic curve multiplication Key Length Requires large primes for security Achieves same strength with smaller keys Performance Moderate to slow Faster due to smaller key size Security Strong, depends on large primes Stronger per bit, more efficient Common Usage SSH, VPNs, older TLS versions TLS 1.3, modern encryption systems <p>Summary</p> <p>Both algorithms provide the same outcome \u2014 secure key establishment \u2014 but ECDH is more efficient and secure for today\u2019s computing environments. For educational and demonstration purposes, the traditional Diffie\u2013Hellman implementation remains an ideal model to understand public-key cryptography concepts.</p>"},{"location":"advantages-limitations/#final-evaluation","title":"Final Evaluation","text":"<p>The implemented DH simulation successfully demonstrates: - Secure key generation and exchange between two users. - Effective validation and error handling mechanisms. - Correct encryption and decryption using the shared key.  </p> <p>While the base Diffie\u2013Hellman algorithm is conceptually simple and effective, its lack of authentication and computational overhead highlight the need for more advanced adaptations in real-world applications.</p>"},{"location":"conclusion/","title":"Conclusion","text":"<p>This project successfully demonstrates the Diffie\u2013Hellman (DH) key exchange in Java, showing how two parties can derive the same secret key over an insecure channel and then use that key to encrypt and decrypt a message. The implementation mirrors the mathematical steps precisely and validates correctness through consistent decryption results.</p>"},{"location":"conclusion/#what-was-achieved","title":"What was achieved","text":"<ul> <li>Implemented DH key establishment with clear separation of concerns across classes.</li> <li>Added robust input validation for ( q ), ( \\alpha ), private keys, and message length.</li> <li>Verified that both parties compute an identical shared key before encryption/decryption.</li> <li>Documented the design, workflow, and test cases with reproducible outputs.</li> </ul>"},{"location":"conclusion/#what-we-learned","title":"What we learned","text":"<ul> <li>How security rests on the hardness of the discrete logarithm problem.</li> <li>The importance of input validation and error handling in crypto demos.</li> <li>Why DH by itself does not provide authentication and must be combined with identity checks in practice.</li> </ul>"},{"location":"conclusion/#limitations-future-work","title":"Limitations &amp; future work","text":"<ul> <li>Authentication: Integrate digital signatures or certificates to prevent MitM attacks.</li> <li>Parameter generation: Add safe prime / generator selection utilities for stronger defaults.</li> <li>Modern variants: Provide an ECDH path (elliptic curves) for smaller keys and faster performance.</li> <li>Testing: Extend property-based tests and large-prime scenarios for stronger assurance.</li> </ul> <p>In summary, the project meets the learning objectives of CS285 by turning theory into a working system and clarifying where real-world protocols extend DH for production-grade security.</p>"},{"location":"implementation/","title":"Implementation","text":"<p>This project was implemented in Java to demonstrate the concepts of the Diffie\u2013Hellman key exchange algorithm. The program allows users to input or automatically generate prime numbers, primitive roots, and private keys. It then performs modular arithmetic to compute the shared secret key between two communicating entities.</p> <p>The overall goal of the implementation is to provide a user-friendly simulation that clearly demonstrates the mathematical steps behind secure key generation.</p>"},{"location":"implementation/#program-structure","title":"Program Structure","text":"<p>The implementation is organized into several classes, each with a specific responsibility that aligns with modular design principles.</p> Class Description <code>Main.java</code> The driver class. Handles user interaction, manages modes (Numerical Example / Live Mode), and displays final results. <code>Parameters.java</code> Stores public parameters such as ( q ) (prime) and ( \\alpha ) (primitive root). <code>KeyExchange.java</code> Generates private and public keys and computes the shared secret key. <code>Encryptor.java</code> Handles message encryption and decryption using the generated shared key. <code>Validator.java</code> Performs validation checks for prime numbers and message length (must exceed 20 characters). <code>Helpers.java</code> Manages all user input, prompts for ( q ), ( \\alpha ), private keys, and ensures validation loops. <code>Utils.java</code> Contains helper functions for random number generation, normalization, and formatted output. <p>Design Principle</p> <p>Each class is responsible for a single functionality, ensuring readability, maintainability, and ease of debugging.</p>"},{"location":"implementation/#workflow-summary","title":"Workflow Summary","text":"<ol> <li>Input Stage \u2013 The user enters a prime number ( q ) and a primitive root ( \\alpha ).  </li> <li>Key Generation Stage \u2013 Each user (A and B) generates private and public keys.  </li> <li>Key Exchange Stage \u2013 Both public keys are exchanged, and each participant calculates the shared secret key.  </li> <li>Encryption Stage \u2013 A plaintext message (&gt; 20 characters) is entered and encrypted using the shared key.  </li> <li>Decryption Stage \u2013 The encrypted text is decrypted to verify successful key exchange and message confidentiality.  </li> </ol>"},{"location":"implementation/#user-interface-and-modes","title":"User Interface and Modes","text":"<p>The system provides two modes for demonstration:</p> Mode Purpose Numerical Example Mode Allows the user to test with predefined small values of ( q ), ( \\alpha ), and private keys for educational demonstration. Live Mode Prompts the user to manually enter or auto-generate parameters, showcasing how the algorithm works in real scenarios."},{"location":"implementation/#example-console-interaction","title":"Example Console Interaction","text":"<p>```bash --- Secure Key Exchange System --- Enter a prime q (\u2265 3): 7 Enter alpha (1 &lt; alpha &lt; q): 6</p> <p>Public Parameters: Prime (q): 7 Primitive Root (alpha): 6</p> <p>Auto private keys generated for both participants.</p> <p>Enter a message (&gt; 20 characters): Please let this project work.</p> <p>--- RESULTS --- q = 7 alpha = 6 Xa = 5 Xb = 3 Ya = 6 Yb = 1 Shared key = 1 Original Message  = Please let this project work. Encrypted Message = Jhs7D0vPYnq0... Decrypted Message = Please let this project work. Decryption OK = true</p>"},{"location":"introduction/","title":"Introduction","text":"<p>The purpose of this project is to implement a secure key exchange system using the Diffie\u2013Hellman algorithm. The algorithm allows two parties to establish a shared secret key through an insecure communication channel without directly sharing any confidential data. This shared key can then be used for encryption and decryption, ensuring that transmitted messages remain private.</p>"},{"location":"introduction/#background","title":"Background","text":"<p>In public-key cryptography, two keys are used \u2014 a public key and a private key. The public key can be openly shared, while the private key must remain secret. The Diffie\u2013Hellman (DH) algorithm specifically enables two participants, often called Alice and Bob, to agree on a mutual secret value by exchanging public parameters. Even if an attacker intercepts these public parameters, they cannot compute the shared key because doing so would require solving the discrete logarithm problem, which is computationally infeasible for large prime numbers.</p>"},{"location":"introduction/#algorithm-overview","title":"Algorithm Overview","text":"<ol> <li>Choose a large prime number ( q ) and a primitive root ( \\alpha ) such that ( 1 &lt; \\alpha &lt; q ).  </li> <li>Each user selects a private key:</li> <li>User A chooses ( X_a )</li> <li>User B chooses ( X_b )</li> <li>Each user computes their public key:</li> <li>( Y_a = \\alpha^{X_a} \\bmod q )</li> <li>( Y_b = \\alpha^{X_b} \\bmod q )</li> <li>Both users exchange their public keys.</li> <li>Each user computes the shared secret key:</li> <li>User A: ( K = Y_b^{X_a} \\bmod q )</li> <li>User B: ( K = Y_a^{X_b} \\bmod q )</li> <li>The result is the same for both: ( K_a = K_b ).</li> </ol> <p>Security Assumption</p> <p>The confidentiality of the shared key relies on the difficulty of computing discrete logarithms \u2014 given ( \\alpha^x \\bmod q ), determining ( x ) is computationally infeasible for sufficiently large ( q ).</p>"},{"location":"introduction/#numerical-example","title":"Numerical Example","text":"<p>To illustrate, assume ( q = 23 ) and ( \\alpha = 5 ). - User A selects a private key ( X_a = 6 ) and computes ( Y_a = 5^6 \\bmod 23 = 8 ). - User B selects ( X_b = 15 ) and computes ( Y_b = 5^{15} \\bmod 23 = 19 ). - Each then computes the shared key:   ( K = 19^6 \\bmod 23 = 2 ) and ( K = 8^{15} \\bmod 23 = 2 ).  </p> <p>Thus, both users derive the same shared secret key ( K = 2 ).</p> <p>Interpretation</p> <p>Even if an attacker observes ( q = 23 ), ( \\alpha = 5 ), ( Y_a = 8 ), and ( Y_b = 19 ), they cannot feasibly compute either private key due to the hardness of the discrete logarithm problem.</p>"},{"location":"references/","title":"References","text":"<ul> <li>Diffie, W., &amp; Hellman, M. (1976). New Directions in Cryptography. IEEE TIT, 22(6), 644\u2013654.  </li> <li>Boneh, D., &amp; Shparlinski, I. E. (2001). On the unpredictability of bits of ECDH. CRYPTO 2001.  </li> <li>Haakegaard, R., &amp; Lang, J. (2015). The Elliptic Curve Diffie\u2013Hellman (ECDH). UCSB.  </li> <li>Ambatipudi, S. (2024). Cryptographic advancements enabled by Diffie\u2013Hellman. ISACA Journal.  </li> <li>Odlyzko, A. M. (2014). Discrete Logarithms in Finite Fields and Their Cryptographic Significance.  </li> <li>Krawczyk, H. (2005). HMQV: A High-Performance Secure Diffie\u2013Hellman Protocol.</li> <li>Alomran, S. F. (2025). CS285 \u2013 Secure Key Exchange Project (Diffie\u2013Hellman Simulation).    Available at: https://github.com/Shoug-Alomran/CS285-CryptographyProject</li> </ul>"},{"location":"results/","title":"Results &amp; Test Cases","text":"<p>This section presents the output of the implemented Diffie\u2013Hellman key exchange system in both Numerical Example and Live Mode. Each result validates the correctness of the shared key computation, encryption, and decryption stages.</p>"},{"location":"results/#live-mode-manual-example","title":"Live Mode \u2013 Manual Example","text":"<p>In the manual live mode, users provide all parameters manually: the prime number ( q ), primitive root ( \\alpha ), and message text. The program validates each input and prevents invalid entries until valid parameters are provided.</p> <p>Once both users (A and B) select their private keys, the program calculates and displays their public keys, followed by the shared key, encrypted message, and decrypted message. Successful decryption proves that both participants derived the same shared key.</p> <p>Observation</p> <p>This confirms that the program correctly implements the mathematical logic of the Diffie\u2013Hellman key exchange algorithm.</p>"},{"location":"results/#live-mode-alpha-error","title":"Live Mode \u2013 Alpha Error","text":"<p>This test demonstrates input validation and error handling. If the user enters a primitive root ( \\alpha ) outside the valid range ( 1 &lt; \\alpha &lt; q ), the program rejects it and prompts the user to re-enter the value.</p> <p>Such validation ensures that invalid parameters do not disrupt the computation or cause a program crash. The system continues to request valid input until a proper value is provided.</p> <p>Validation Mechanism</p> <p>The <code>Validator</code> and <code>Helpers</code> classes work together to ensure that both the prime number ( q ) and the primitive root ( \\alpha ) meet mathematical constraints before proceeding.</p>"},{"location":"results/#numerical-example-fixed","title":"Numerical Example (Fixed)","text":"<p>This example uses small integer values to visually demonstrate how two users can derive the same shared secret key step-by-step. Although the numbers are small, the logic mirrors real-world key exchange systems that operate with very large primes.</p> Parameter Value Prime number (q) 7 Primitive root (\u03b1) 6 Private key X\u2090 5 Private key X\u1d66 3 Shared key (K) 1 <p>Result Verification</p> <p>Both participants derive the same shared key, confirming successful implementation. This test serves as an educational demonstration of the core concept behind the Diffie\u2013Hellman key exchange.</p>"},{"location":"results/#comparison-diffiehellman-dh-vs-elliptic-curve-diffiehellman-ecdh","title":"Comparison: Diffie\u2013Hellman (DH) vs. Elliptic Curve Diffie\u2013Hellman (ECDH)","text":"<p>To provide broader context, this diagram compares the traditional Diffie\u2013Hellman (DH) and Elliptic Curve Diffie\u2013Hellman (ECDH) methods.</p> Aspect DH ECDH Mathematical Basis Modular exponentiation Elliptic curve point multiplication Key Size Larger (requires big primes) Smaller (same security with shorter keys) Computational Efficiency Slower Faster Security Strength Strong but depends on prime size Stronger per bit; harder to break Use Cases Older implementations (VPNs, SSH) Modern secure systems (TLS 1.3, Signal) <p>Summary</p> <p>Both algorithms achieve the same goal \u2014 establishing a shared secret key over an insecure channel. However, ECDH provides greater efficiency and stronger security with smaller key sizes, making it the preferred approach in most modern cryptographic protocols.</p>"},{"location":"team/","title":"Team Contribution","text":"Member Student ID Core Contributions Shoug Fawaz Abdullah Alomran 223410392 Validation, integration, driver <code>Main</code>, Helpers class, test flows, report assembly, MkDocs site. Fai Mohammad Bin Khanjar 223410071 Key generation math &amp; shared secret logic; numerical example; review of modular operations. Aljohara Waleed A Albawardi 223410346 <code>Encryptor</code> (hash \u2192 XOR stream), encryption/decryption tests, screenshots. Yara Mutlaq Mohammed Alzamel 223410834 Public parameters scaffolding, utilities, formatting helpers, program flow description. <p>We coordinated via Git/GitHub, standardized method names, and iterated on validation until all flows were robust.</p>"},{"location":"code/encryptor/","title":"Encryptor","text":"<p>```java title=\"Encryptor.java\" import java.math.BigInteger; import java.util.Base64; import java.security.MessageDigest; import java.nio.charset.StandardCharsets;</p> <p>public class Encryptor {</p> <pre><code>// Convert shared BigInteger key into a byte array (keyByte)\n// Uses BigInteger for very large values\nprivate byte[] Key(BigInteger key) throws Exception {\n    MessageDigest msgDigest = MessageDigest.getInstance(\"SHA-256\"); // SHA for Secure Hash Algorithm (256-bit output)\n    byte[] ArrayByte = key.toByteArray(); // Converts the shared key into bytes\n    return msgDigest.digest(ArrayByte);   // Hashes the byte array to produce a fixed-length key\n}\n\n// XOR function for symmetric encryption/decryption\nprivate byte[] xor(byte[] data, byte[] key) {\n    byte[] xorArray = new byte[data.length]; // Creates a new byte array to store the result\n    for (int i = 0; i &lt; data.length; i++) {\n        xorArray[i] = (byte) (data[i] ^ key[i % key.length]); // XORs each byte with the corresponding key byte\n    }\n    return xorArray;\n}\n\n// Encrypt a message using the shared secret key\nString encrypt(String msg, BigInteger sharedKey) throws Exception {\n    byte[] msgByte = msg.getBytes(StandardCharsets.UTF_8); // Converts text to bytes\n    byte[] keyByte = Key(sharedKey);                        // Derives the key bytes\n    byte[] cipherMsgByte = xor(msgByte, keyByte);           // Encrypts using XOR\n    return Base64.getEncoder().encodeToString(cipherMsgByte); // Encodes ciphertext in Base64\n}\n\n// Decrypt a Base64 ciphertext using the shared secret key\nString decrypt(String base64cipherMsg, BigInteger sharedKey) throws Exception {\n    byte[] keyByte = Key(sharedKey);                         // Regenerate the key\n    byte[] cipherMsgByte = Base64.getDecoder().decode(base64cipherMsg); // Decode Base64 input\n    byte[] msgByte = xor(cipherMsgByte, keyByte);            // Decrypt using XOR\n    return new String(msgByte, StandardCharsets.UTF_8);      // Convert bytes back to readable text\n}\n\n// Validate message before encryption\npublic static void validateMsg(String msg) {\n    if (msg == null) {\n        throw new IllegalArgumentException(\"Message cannot be empty\");\n    }\n}\n\n// Validate cipher text before decryption\npublic static void validateCipherMsg(String cipherMsg) {\n    if (cipherMsg == null) {\n        throw new IllegalArgumentException(\"Cipher message cannot be empty\");\n    }\n}\n</code></pre> <p>}</p>"},{"location":"code/helpers/","title":"Helpers","text":"<p>```java title=\"Helpers.java\" import java.math.BigInteger; import java.security.SecureRandom; import java.util.Scanner;</p> <p>public class Helpers {</p> <pre><code>// 1) Prompt for a prime q (\u2265 3). Re-prompts until valid.\npublic static BigInteger promptPrime(Scanner input) {\n    while (true) {\n        try {\n            System.out.print(\"Enter a prime q (\u2265 3): \");\n            BigInteger q = new BigInteger(input.nextLine().trim());\n            if (Validator.isPrime(q)) return q;\n            System.out.println(\"That's not a prime number. Try again.\\n\");\n        } catch (Exception e) {\n            System.out.println(\"Invalid input. Please type an integer.\\n\");\n        }\n    }\n}\n\n// 2) Prompt for alpha with range check 1 &lt; alpha &lt; q. Re-prompts until valid.\npublic static BigInteger promptAlpha(Scanner in, BigInteger q) {\n    while (true) {\n        try {\n            System.out.print(\"Enter alpha (1 &lt; alpha &lt; q): \");\n            BigInteger alpha = new BigInteger(in.nextLine().trim());\n            if (Validator.isAlphaInRange(alpha, q)) return alpha;\n            System.out.println(\"Alpha must be &gt; 1 and &lt; q. Try again.\\n\");\n        } catch (Exception e) {\n            System.out.println(\"Invalid input. Please type an integer.\\n\");\n        }\n    }\n}\n\n// 3) Prompt for private keys in the inclusive range [1 .. q\u22122]. Re-prompts until valid.\npublic static BigInteger promptPrivateKey(Scanner input, BigInteger q, String message) {\n    System.out.println(\"\\nPrivate keys must be integers between 1 and q-2 (inclusive).\");\n    BigInteger min = BigInteger.ONE;\n    BigInteger max = q.subtract(BigInteger.TWO); // q-2\n    while (true) {\n        try {\n            System.out.print(message);\n            BigInteger x = new BigInteger(input.nextLine().trim());\n            if (x.compareTo(min) &gt;= 0 &amp;&amp; x.compareTo(max) &lt;= 0) return x;\n            System.out.println(\"Invalid range. Please enter a value between 1 and q-2.\\n\");\n        } catch (Exception e) {\n            System.out.println(\"Invalid input. Please type an integer.\\n\");\n        }\n    }\n}\n\n// 4) Generate a random private key uniformly in [1 .. q\u22122].\npublic static BigInteger randomPrivateKey(BigInteger q, SecureRandom rnd) {\n    BigInteger min = BigInteger.ONE;\n    BigInteger max = q.subtract(BigInteger.TWO);               // q - 2\n    BigInteger range = max.subtract(min).add(BigInteger.ONE);  // (q-2) - 1 + 1 = q-2\n\n    BigInteger r;\n    do {\n        // sample enough bits; reject if &gt;= range to avoid bias, then shift by +min\n        r = new BigInteger(range.bitLength(), rnd);\n    } while (r.compareTo(range) &gt;= 0);\n    return r.add(min);\n}\n\n// 5) Prompt for a message (&gt; 20 characters). Re-prompts until valid.\npublic static String promptMessage(Scanner input) {\n    while (true) {\n        System.out.print(\"Enter a message (&gt; 20 characters): \");\n        String message = input.nextLine();\n        if (Validator.isValidMessage(message)) return message;\n        System.out.println(\"Message too short. Please try again (must be &gt; 20 characters).\\n\");\n    }\n}\n</code></pre> <p>}</p>"},{"location":"code/keyexchange/","title":"Key Exchange","text":"<p>import java.math.BigInteger; import java.security.SecureRandom;</p> <p>public class KeyExchange extends Parameters {</p> <pre><code>private SecureRandom random = new SecureRandom();\n\n// Attributes to store keys\nprivate BigInteger privateKey;\nprivate BigInteger publicKey;\n\n// Constructor calls Parameters constructor and generates both keys\npublic KeyExchange(BigInteger q, BigInteger alpha) {\n    super(q, alpha);\n    generateKeys(); // Generate public and private keys when object is created\n}\n\n// Generate a random private key and corresponding public key\nprivate void generateKeys() {\n    // Generate private key: 1 \u2264 x \u2264 q\u22122\n    this.privateKey = new BigInteger(getQ().bitLength(), random)\n            .mod(getQ().subtract(BigInteger.TWO))\n            .add(BigInteger.ONE);\n\n    // Compute public key: Y = \u03b1^x mod q\n    this.publicKey = getAlpha().modPow(privateKey, getQ());\n}\n\n// Compute shared key using peer's public key\npublic BigInteger computeSharedKey(BigInteger otherPublic) {\n    return otherPublic.modPow(privateKey, getQ());\n}\n\n// Getter for private key\npublic BigInteger getPrivateKey() {\n    return privateKey;\n}\n\n// Getter for public key\npublic BigInteger getPublicKey() {\n    return publicKey;\n}\n</code></pre> <p>}</p>"},{"location":"code/main/","title":"Main","text":"<p>```java title=\"Main.java\" import java.math.BigInteger; import java.security.SecureRandom; import java.util.Scanner;</p> <p>public class Main {</p> <pre><code>private static final SecureRandom random = new SecureRandom();\n\npublic static void main(String[] args) {\n    Scanner input = new Scanner(System.in);\n\n    System.out.println(\"--- Royal Convoy - Secure Communication (Diffie-Hellman / ECDH Demo) ---\");\n    System.out.println(\"This program demonstrates how the control center and vehicles exchange keys securely.\\n\");\n\n    while (true) {\n        System.out.println(\"MAIN MENU:\");\n        System.out.println(\"1) Numerical Example (Section 1.3 demo - fixed values)\");\n        System.out.println(\"2) Numerical Example (auto-generated values)\");\n        System.out.println(\"3) Live Mode (manual / auto parameters and private keys)\");\n        System.out.println(\"0) Exit\");\n        System.out.print(\"Choose an option: \");\n\n        String choice = input.nextLine().trim();\n\n        switch (choice) {\n            case \"1\" -&gt; runFixedExample();\n            case \"2\" -&gt; runRandomExample(input);\n            case \"3\" -&gt; runLiveMode(input);\n            case \"0\" -&gt; {\n                System.out.println(\"Goodbye!\");\n                input.close();\n                return;\n            }\n            default -&gt; System.out.println(\"Invalid choice. Please enter 1, 2, 3, or 0.\\n\");\n        }\n    }\n}\n\n// \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Numerical Example \u2013 Fixed (as in report) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nprivate static void runFixedExample() {\n    System.out.println(\"\\n--- Numerical Example (Section 1.3 - Fixed) ---\");\n\n    BigInteger q = BigInteger.valueOf(23);\n    BigInteger alpha = BigInteger.valueOf(5);\n    Parameters storage = new Parameters(q, alpha);\n\n    BigInteger Xa = BigInteger.valueOf(6);\n    BigInteger Xb = BigInteger.valueOf(15);\n\n    BigInteger Ya = alpha.modPow(Xa, q);\n    BigInteger Yb = alpha.modPow(Xb, q);\n    BigInteger kA = Yb.modPow(Xa, q);\n    BigInteger kB = Ya.modPow(Xb, q);\n\n    System.out.println(\"To give an example, both 2 cars and the control center need a safe way to communicate.\");\n    System.out.println(storage);\n    System.out.println(\"Car 1 chooses Xa = 6 \u2192 Ya = 5^6 mod 23 = \" + Ya);\n    System.out.println(\"Car 2 chooses Xb = 15 \u2192 Yb = 5^15 mod 23 = \" + Yb);\n    System.out.println(\"Each car computes the shared key:\");\n    System.out.println(\"Car 1: 19^6 mod 23 = \" + kA);\n    System.out.println(\"Car 2: 8^15 mod 23 = \" + kB);\n    System.out.println(\"Both cars share the same key: \" + kA + \"\\n\");\n\n    String message = \"Royal convoy message remains secure through shared key exchange.\";\n    System.out.println(\"Example message: \" + message);\n\n    try {\n        Encryptor enc = new Encryptor();\n        String cipher = enc.encrypt(message, kA);\n        String plain = enc.decrypt(cipher, kB);\n        System.out.println(\"Encrypted Message = \" + cipher);\n        System.out.println(\"Decrypted Message = \" + plain);\n        System.out.println(\"Decryption OK = \" + plain.equals(message) + \"\\n\");\n    } catch (Exception e) {\n        System.out.println(\"Encryption/Decryption failed: \" + e.getMessage());\n    }\n}\n\n// \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Numerical Example \u2013 Random \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nprivate static void runRandomExample(Scanner input) {\n    System.out.println(\"\\n--- Numerical Example (Auto-generated values) ---\");\n\n    BigInteger q = BigInteger.probablePrime(8, random);\n    BigInteger alpha = BigInteger.valueOf(random.nextInt(3, q.intValue() - 1));\n    Parameters storage = new Parameters(q, alpha);\n\n    BigInteger Xa = BigInteger.valueOf(random.nextInt(2, q.intValue() - 2));\n    BigInteger Xb = BigInteger.valueOf(random.nextInt(2, q.intValue() - 2));\n\n    BigInteger Ya = alpha.modPow(Xa, q);\n    BigInteger Yb = alpha.modPow(Xb, q);\n    BigInteger kA = Yb.modPow(Xa, q);\n    BigInteger kB = Ya.modPow(Xb, q);\n\n    System.out.println(\"Automatically generated example parameters and results:\");\n    System.out.println(storage);\n    System.out.println(\"Car 1 (Xa): \" + Xa + \" --&gt; Ya = \" + Ya);\n    System.out.println(\"Car 2 (Xb): \" + Xb + \" --&gt; Yb = \" + Yb);\n    System.out.println(\"Shared key for Car 1: \" + kA);\n    System.out.println(\"Shared key for Car 2: \" + kB);\n    System.out.println(\"Keys match: \" + kA.equals(kB) + \"\\n\");\n\n    String message = Helpers.promptMessage(input);\n\n    try {\n        Encryptor enc = new Encryptor();\n        String cipher = enc.encrypt(message, kA);\n        String plain = enc.decrypt(cipher, kB);\n        System.out.println(\"--- Encryption Test ---\");\n        System.out.println(\"Original Message  = \" + message);\n        System.out.println(\"Encrypted Message = \" + cipher);\n        System.out.println(\"Decrypted Message = \" + plain);\n        System.out.println(\"Decryption OK = \" + plain.equals(message) + \"\\n\");\n    } catch (Exception e) {\n        System.out.println(\"Encryption/Decryption failed: \" + e.getMessage());\n    }\n}\n\n// \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Live Mode (manual or auto q, alpha, and keys) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nprivate static void runLiveMode(Scanner input) {\n    System.out.println(\"\\n--- Live Mode ---\");\n    System.out.println(\"You can either enter your own values for q and alpha, or let the program generate them.\\n\");\n\n    System.out.println(\"Choose parameter mode:\");\n    System.out.println(\"a) Auto-generate q and alpha\");\n    System.out.println(\"b) Enter manually\");\n    System.out.print(\"Your choice (a/b): \");\n    String paramChoice = input.nextLine().trim().toLowerCase();\n\n    BigInteger q, alpha;\n\n    if (\"b\".equals(paramChoice)) {\n        q = Helpers.promptPrime(input);\n        alpha = Helpers.promptAlpha(input, q);\n    } else {\n        q = BigInteger.probablePrime(8, random);\n        alpha = BigInteger.valueOf(random.nextInt(3, q.intValue() - 1));\n        System.out.println(\"Automatically generated parameters:\");\n        System.out.println(\"q = \" + q + \", alpha = \" + alpha + \"\\n\");\n    }\n\n    Parameters storage = new Parameters(q, alpha);\n    System.out.println(storage + \"\\n\");\n\n    System.out.println(\"Choose private-key mode:\");\n    System.out.println(\"a) Auto-generate private keys\");\n    System.out.println(\"b) Enter private keys manually\");\n    System.out.print(\"Your choice (a/b): \");\n    String keyChoice = input.nextLine().trim().toLowerCase();\n\n    BigInteger Xa, Xb;\n    if (\"b\".equals(keyChoice)) {\n        Xa = Helpers.promptPrivateKey(input, q, \"Enter private key for Car 1: \");\n        Xb = Helpers.promptPrivateKey(input, q, \"Enter private key for Car 2: \");\n    } else {\n        Xa = BigInteger.valueOf(random.nextInt(2, q.intValue() - 2));\n        Xb = BigInteger.valueOf(random.nextInt(2, q.intValue() - 2));\n        System.out.println(\"Auto private keys generated: Xa = \" + Xa + \", Xb = \" + Xb + \"\\n\");\n    }\n\n    BigInteger Ya = alpha.modPow(Xa, q);\n    BigInteger Yb = alpha.modPow(Xb, q);\n    BigInteger kA = Yb.modPow(Xa, q);\n    BigInteger kB = Ya.modPow(Xb, q);\n\n    if (!kA.equals(kB)) {\n        System.out.println(\"Shared keys do not match. Please try again.\\n\");\n        return;\n    }\n\n    String message = Helpers.promptMessage(input);\n\n    try {\n        Encryptor enc = new Encryptor();\n        String cipher = enc.encrypt(message, kA);\n        String plain = enc.decrypt(cipher, kB);\n\n        System.out.println(\"\\n--- RESULTS ---\");\n        System.out.println(\"q = \" + q);\n        System.out.println(\"alpha = \" + alpha);\n        System.out.println(\"Xa = \" + Xa);\n        System.out.println(\"Xb = \" + Xb);\n        System.out.println(\"Ya = \" + Ya);\n        System.out.println(\"Yb = \" + Yb);\n        System.out.println(\"Shared key = \" + kA);\n        System.out.println(\"Original Message = \" + message);\n        System.out.println(\"Encrypted Message = \" + cipher);\n        System.out.println(\"Decrypted Message = \" + plain);\n        System.out.println(\"Decryption OK = \" + plain.equals(message));\n        System.out.println(\"Secure session established between convoy vehicles and control center.\\n\");\n\n    } catch (Exception e) {\n        System.out.println(\"Encryption/Decryption failed: \" + e.getMessage());\n    }\n}\n</code></pre> <p>}</p>"},{"location":"code/parameters/","title":"Parameters","text":"<p>```java title=\"Parameters.java\" import java.math.BigInteger;</p> <p>public class Parameters {</p> <pre><code>// Public parameters\nprivate BigInteger q;\nprivate BigInteger alpha;\n\n// Constructor that sets q and alpha\npublic Parameters(BigInteger q, BigInteger alpha) {\n    this.q = q;\n    this.alpha = alpha;\n}\n\n// Getter for q\npublic BigInteger getQ() {\n    return q;\n}\n\n// Getter for alpha\npublic BigInteger getAlpha() {\n    return alpha;\n}\n\n@Override\npublic String toString() {\n    return \"Public Parameters:\\n\" +\n           \"Prime number (q): \" + q + \"\\n\" +\n           \"Primitive root (alpha): \" + alpha;\n}\n</code></pre> <p>}</p>"},{"location":"code/utils/","title":"Utils","text":"<p>```java title=\"Utils.java\" import java.math.BigInteger; import java.security.SecureRandom;</p> <p>public class Utils {</p> <pre><code>// Create a static SecureRandom object for use across classes\nprivate static final SecureRandom secureRandom = new SecureRandom();\n\n// getRandom(upperLimit)\n// Returns a random BigInteger in the range [1, upperLimit - 1]\npublic static BigInteger getRandom(BigInteger upperLimit) {\n    BigInteger result;\n    do {\n        result = new BigInteger(upperLimit.bitLength(), secureRandom);\n    } while (result.compareTo(BigInteger.ONE) &lt; 0 || result.compareTo(upperLimit) &gt;= 0);\n    return result;\n}\n\n// printLine(label, value)\n// Formats console output for screenshots (e.g., \"User A public key: 8\")\npublic static void printLine(String label, Object value) {\n    System.out.println(label + \": \" + value);\n}\n\n// normalizeKeyBytes(key)\n// Removes the leading zero byte if present in key.toByteArray()\npublic static byte[] normalizeKeyBytes(BigInteger key) {\n    byte[] bytes = key.toByteArray();\n    if (bytes.length &gt; 1 &amp;&amp; bytes[0] == 0) {\n        byte[] normalized = new byte[bytes.length - 1];\n        System.arraycopy(bytes, 1, normalized, 0, normalized.length);\n        return normalized;\n    }\n    return bytes;\n}\n</code></pre> <p>}</p>"},{"location":"code/validator/","title":"Validator","text":"<p>```java title=\"Validator.java\" import java.math.BigInteger;</p> <p>/*  * Minimal Validator class for validating prime numbers, alpha values,   * and message lengths used in the Diffie\u2013Hellman key exchange system.  / public class Validator {</p> <pre><code>// Check if q is a prime number \u2265 3\npublic static boolean isPrime(BigInteger q) {\n    if (q == null) return false;\n    if (q.compareTo(BigInteger.valueOf(3)) &lt; 0) return false; // reject &lt; 3\n    return q.isProbablePrime(100); // Miller\u2013Rabin test built into BigInteger\n}\n\n// Check if 1 &lt; alpha &lt; q\npublic static boolean isAlphaInRange(BigInteger alpha, BigInteger q) {\n    return alpha != null &amp;&amp; q != null\n            &amp;&amp; alpha.compareTo(BigInteger.ONE) &gt; 0\n            &amp;&amp; alpha.compareTo(q) &lt; 0;\n}\n\n// Check if message has more than 20 non-space characters\npublic static boolean isValidMessage(String message) {\n    return message != null &amp;&amp; message.trim().length() &gt; 20;\n}\n</code></pre> <p>}</p>"}]}