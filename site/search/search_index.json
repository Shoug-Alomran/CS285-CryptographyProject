{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Discrete Mathematics for Computing: Secure Key Exchange Project","text":"Purpose: Provide a clear, course-aligned overview of the CS285 project, its learning goals, and its cryptographic scope. <p>University: Prince Sultan University Course: CS285 - Discrete Mathematics for Computing Project Title: Secure Key Exchange System (Diffie-Hellman Demonstration) Instructor: Dr. Jalila Zouhair Submission Date: November 9, 2025</p> <p>Team Members</p> <ul> <li>Shoug Fawaz Alomran</li> <li>Fai Mohammad Khanjar</li> <li>Aljoharah Waleed Albawardi</li> <li>Yara Mutlaq Alzamel</li> </ul>"},{"location":"#abstract","title":"Abstract","text":"<p>This project demonstrates how two participants can establish a shared secret using public-key cryptography. The implementation uses the Diffie-Hellman key exchange algorithm, allowing key establishment over an insecure channel without transmitting private values.</p> <p>After the shared secret is derived, the system uses it for message encryption and decryption. The project also includes validation checks, error handling, and two operating modes: a guided numerical example and an interactive live mode.</p>"},{"location":"#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Apply discrete mathematics concepts used in public-key cryptography.</li> <li>Implement Diffie-Hellman key exchange in Java.</li> <li>Verify that both participants derive the same shared secret.</li> <li>Use the shared secret for encryption and decryption flow validation.</li> <li>Document architecture, code behavior, and test evidence in a reproducible format.</li> </ul> <p>Key Insight</p> <p>Diffie-Hellman security relies on the practical difficulty of solving the discrete logarithm problem for large parameter choices.</p>"},{"location":"about/","title":"About the Project","text":"Purpose: Define the project scope and explain how the CS285 implementation connects theory with working software. <p>The Secure Key Exchange System was developed for CS285 - Discrete Mathematics for Computing at Prince Sultan University.</p> <p>The website consolidates the project report, implementation notes, source code references, and test outcomes. The core demonstration shows how two participants establish a shared secret key using Diffie-Hellman in Java.</p>"},{"location":"about/#project-purpose","title":"Project Purpose","text":"<p>This project was designed to:</p> <ol> <li>Apply modular arithmetic and discrete logarithm concepts in a practical setting.</li> <li>Implement Diffie-Hellman key exchange with clear parameter handling.</li> <li>Show how a shared secret can support encryption and decryption.</li> <li>Reinforce core public-key cryptography principles through reproducible examples.</li> </ol> <p>Educational Scope</p> <p>This implementation is an instructional proof-of-concept intended to bridge mathematical foundations and software execution.</p>"},{"location":"advantages-limitations/","title":"Advantages and Limitations","text":"Purpose: Evaluate the strengths and practical constraints of Diffie-Hellman within this course implementation context. <p>Diffie-Hellman (DH) enables two parties to agree on a shared secret over an insecure channel without transmitting private keys directly. It remains foundational, but secure deployment requires careful protocol design.</p>"},{"location":"advantages-limitations/#advantages","title":"Advantages","text":"<ol> <li>No pre-shared secret required    Parties can establish a key without a prior secure channel.</li> <li>Forward secrecy potential    Ephemeral DH sessions can help protect past traffic if long-term secrets are later compromised.</li> <li>Strong mathematical basis    Security is linked to the hardness of the discrete logarithm problem for suitable groups.</li> <li>Widespread protocol relevance    DH-based constructions are central to secure protocol history and modern variants.</li> </ol> <p>Implementation Context</p> <p>Larger primes and session-specific values increase practical resistance to attack.</p>"},{"location":"advantages-limitations/#limitations","title":"Limitations","text":"<ol> <li>No built-in authentication    Plain DH does not verify identities.</li> <li>MitM exposure without authentication    Attackers can relay and replace public values if identity checks are absent.</li> <li>Parameter quality matters    Weak or reused parameters can reduce security margins.</li> <li>Computational overhead    Modular exponentiation is heavier than symmetric operations.</li> </ol> <p>Security Note</p> <p>Production use should pair key exchange with authentication (for example certificates or signatures).</p>"},{"location":"advantages-limitations/#dh-and-ecdh-at-a-glance","title":"DH and ECDH at a Glance","text":"Aspect DH ECDH Mathematical basis Modular exponentiation Elliptic-curve point multiplication Typical key size Larger for equivalent strength Smaller for equivalent strength Performance Moderate Generally faster at comparable security Common use today Legacy and educational contexts Modern protocol deployments"},{"location":"advantages-limitations/#final-evaluation","title":"Final Evaluation","text":"<p>This project demonstrates successful shared-key establishment, robust input validation, and consistent encryption/decryption behavior. At the same time, it correctly highlights why standalone DH must be extended with authentication in real-world systems.</p>"},{"location":"conclusion/","title":"Conclusion","text":"Purpose: Summarize project outcomes, learning impact, and practical next steps. <p>The project successfully demonstrates Diffie-Hellman key exchange in Java and verifies that both participants compute the same secret key before encrypted communication.</p>"},{"location":"conclusion/#what-was-achieved","title":"What Was Achieved","text":"<ul> <li>Implemented complete DH key establishment flow with clear class responsibilities.</li> <li>Added input validation for \\( q \\), \\( \\alpha \\), private-key ranges, and message length.</li> <li>Verified end-to-end encryption/decryption consistency using the shared secret.</li> <li>Produced report and test evidence aligned with course expectations.</li> </ul>"},{"location":"conclusion/#what-was-learned","title":"What Was Learned","text":"<ul> <li>How discrete mathematics directly drives public-key protocol behavior.</li> <li>Why validation and controlled input flow are critical in cryptographic software.</li> <li>Why DH alone is insufficient without an authentication layer.</li> </ul>"},{"location":"conclusion/#limitations-and-future-work","title":"Limitations and Future Work","text":"<ul> <li>Add authenticated key exchange support (for example, signature-backed identity checks).</li> <li>Improve parameter generation defaults (safe-prime and generator policies).</li> <li>Add an ECDH path for modern performance/security comparison.</li> <li>Expand automated tests, including larger parameter scenarios.</li> </ul> <p>Overall, the project meets the CS285 learning objective of turning theory into a reproducible cryptographic implementation.</p>"},{"location":"copyright/","title":"Copyright and Usage Policy","text":"<p>\u00a9 2026 Shoug Fawaz Alomran. All rights reserved.</p> Purpose: Clarify permitted educational use and restrictions for project assets and documentation. <p>All content under this project domain, including software, source code, documents, visuals, research text, and supporting material, is protected by applicable copyright law.</p>"},{"location":"copyright/#permitted-use","title":"Permitted Use","text":"<ul> <li>Personal, educational, and non-commercial viewing or citation.</li> <li>Short quotations with proper attribution.</li> </ul>"},{"location":"copyright/#prohibited-use","title":"Prohibited Use","text":"<ul> <li>Full reproduction or redistribution of complete project assets.</li> <li>Commercial use without written permission.</li> <li>Misattribution or claims of authorship.</li> </ul>"},{"location":"copyright/#licensing","title":"Licensing","text":"<p>Some subprojects may include separate licenses. When present, project-level license terms override this page only where explicitly stated.</p>"},{"location":"copyright/#contact","title":"Contact","text":"<p>For licensing or permission inquiries: <code>Shoug.Alomran@Shoug-Tech.com</code></p>"},{"location":"implementation/","title":"Implementation","text":"Purpose: Document class responsibilities, execution flow, and operating modes of the Java implementation. <p>The project is implemented in Java as a transparent simulation of Diffie-Hellman key exchange. Users can supply parameters manually or generate them automatically, then verify key agreement through encryption and decryption output.</p>"},{"location":"implementation/#program-structure","title":"Program Structure","text":"Class Responsibility <code>Main.java</code> Application entry point, menu flow, mode selection, and final result display. <code>Parameters.java</code> Stores public parameters \\( q \\) and \\( \\alpha \\). <code>KeyExchange.java</code> Computes public keys and shared secret values. <code>Encryptor.java</code> Encrypts and decrypts messages using the shared secret. <code>Validator.java</code> Validates prime checks, parameter ranges, and message constraints. <code>Helpers.java</code> Handles input prompts and validation loops. <code>Utils.java</code> Provides support utilities such as random generation and formatting helpers. <p>Design Principle</p> <p>The code follows separation of concerns so each class has a focused role.</p>"},{"location":"implementation/#workflow-summary","title":"Workflow Summary","text":"<ol> <li>Input stage: Collect \\( q \\) and \\( \\alpha \\).</li> <li>Key stage: Each participant selects a private key and computes a public key.</li> <li>Exchange stage: Public keys are exchanged; each side computes a shared secret.</li> <li>Encryption stage: A plaintext message (more than 20 characters) is encrypted.</li> <li>Decryption stage: Ciphertext is decrypted to confirm correctness.</li> </ol>"},{"location":"implementation/#user-modes","title":"User Modes","text":"Mode Purpose Numerical Example Demonstrates the process with small educational values. Live Mode Uses manual or auto-generated values for interactive testing."},{"location":"implementation/#example-console-interaction","title":"Example Console Interaction","text":"<pre><code>--- Royal Convoy - Secure Communication (Diffie-Hellman / ECDH Demo) ---\nThis program demonstrates how the control center and vehicles exchange keys securely.\n\nMAIN MENU:\n1) Numerical Example (Section 1.3 demo - fixed values)\n2) Numerical Example (auto-generated values)\n3) Live Mode (manual / auto parameters and private keys)\n0) Exit\nChoose an option: 3\n...\nShared key = 7\nOriginal Message  = Please let this project work.\nEncrypted Message = Jhs7D0vPYnq0...\nDecrypted Message = Please let this project work.\nDecryption OK = true\n</code></pre>"},{"location":"introduction/","title":"Introduction","text":"Purpose: Introduce the Diffie-Hellman model, core assumptions, and a verified numerical example. <p>This project implements a secure key exchange system using the Diffie-Hellman algorithm. Two participants can derive the same secret key over an insecure channel without directly sharing private keys.</p> <p>The derived key is then used for encryption and decryption, demonstrating confidentiality in a simplified educational workflow.</p>"},{"location":"introduction/#background","title":"Background","text":"<p>In public-key cryptography, public values are shared while private values remain secret. Diffie-Hellman enables participants (commonly Alice and Bob) to agree on a mutual secret through exponentiation in modular arithmetic.</p> <p>An observer can see the public parameters and public keys, but deriving the private keys is computationally hard because it requires solving the discrete logarithm problem for suitably large parameters.</p>"},{"location":"introduction/#algorithm-overview","title":"Algorithm Overview","text":"<ol> <li>Select a prime number \\( q \\) and a primitive root \\( \\alpha \\), with \\( 1 &lt; \\alpha &lt; q \\).</li> <li>Participant A chooses private key \\( X_a \\), and participant B chooses private key \\( X_b \\).</li> <li>Compute public keys:</li> <li>\\( Y_a = \\alpha^{X_a} \\bmod q \\)</li> <li>\\( Y_b = \\alpha^{X_b} \\bmod q \\)</li> <li>Exchange public keys.</li> <li>Compute shared secret on both sides:</li> <li>A computes \\( K = Y_b^{X_a} \\bmod q \\)</li> <li>B computes \\( K = Y_a^{X_b} \\bmod q \\)</li> <li>Both obtain the same result: \\( K_a = K_b \\).</li> </ol> <p>Security Assumption</p> <p>Given \\( \\alpha^x \\bmod q \\), recovering \\( x \\) is infeasible in practice for strong parameter sizes.</p>"},{"location":"introduction/#numerical-example","title":"Numerical Example","text":"<p>Using \\( q = 23 \\) and \\( \\alpha = 5 \\):</p> <ul> <li>A chooses \\( X_a = 6 \\), so \\( Y_a = 5^6 \\bmod 23 = 8 \\).</li> <li>B chooses \\( X_b = 15 \\), so \\( Y_b = 5^{15} \\bmod 23 = 19 \\).</li> <li>Shared key from each side:</li> <li>\\( K = 19^6 \\bmod 23 = 2 \\)</li> <li>\\( K = 8^{15} \\bmod 23 = 2 \\)</li> </ul> <p>Both participants derive the same shared secret: \\( K = 2 \\).</p> <p>Interpretation</p> <p>Public values alone (\\( q, \\alpha, Y_a, Y_b \\)) are not enough to feasibly recover private keys under standard assumptions.</p>"},{"location":"references/","title":"References","text":"Purpose: List primary sources used for cryptographic foundations and project context. <ul> <li>Diffie, W., &amp; Hellman, M. (1976). New Directions in Cryptography. IEEE Transactions on Information Theory, 22(6), 644-654.</li> <li>Boneh, D., &amp; Shparlinski, I. E. (2001). On the unpredictability of bits of ECDH. CRYPTO 2001.</li> <li>Haakegaard, R., &amp; Lang, J. (2015). The Elliptic Curve Diffie-Hellman (ECDH). UCSB.</li> <li>Ambatipudi, S. (2024). Cryptographic advancements enabled by Diffie-Hellman. ISACA Journal.</li> <li>Odlyzko, A. M. (2014). Discrete Logarithms in Finite Fields and Their Cryptographic Significance.</li> <li>Krawczyk, H. (2005). HMQV: A High-Performance Secure Diffie-Hellman Protocol.</li> <li>Alomran, S. F. (2025). CS285 Secure Key Exchange Project (Diffie-Hellman Simulation).   Repository: GitHub Project</li> </ul>"},{"location":"results/","title":"Results and Test Cases","text":"Purpose: Present evidence that parameter validation, key agreement, and encryption/decryption flows work correctly. <p>This section summarizes representative outputs from the implemented Diffie-Hellman system across live and numerical test scenarios.</p>"},{"location":"results/#live-mode-manual-example","title":"Live Mode: Manual Example","text":"<p>In manual live mode, users enter \\( q \\), \\( \\alpha \\), and the message directly. The system validates each input before continuing.</p> <p>After key generation and exchange, both participants derive the same shared key, then encrypt and decrypt the message successfully.</p> <p>Observation</p> <p>Matching decrypted output confirms successful shared-key derivation and correct message flow.</p>"},{"location":"results/#live-mode-invalid-alpha-input","title":"Live Mode: Invalid Alpha Input","text":"<p>This case verifies input validation behavior. If a user provides \\( \\alpha \\) outside the valid range \\( 1 &lt; \\alpha &lt; q \\), the program rejects it and asks for a valid value.</p> <p>Validation Path</p> <p><code>Validator</code> and <code>Helpers</code> jointly enforce numeric and range constraints before any cryptographic computation.</p>"},{"location":"results/#numerical-example-fixed-values","title":"Numerical Example (Fixed Values)","text":"<p>This test uses small values for transparent, step-by-step verification.</p> Parameter Value Prime number (q) 7 Primitive root (alpha) 6 Private key \\(X_a\\) 5 Private key \\(X_b\\) 3 Shared key (K) 1 <p>Result Verification</p> <p>Both participants compute the same shared key, validating implementation correctness.</p>"},{"location":"results/#dh-vs-ecdh-comparison","title":"DH vs ECDH Comparison","text":"<p>This visual comparison places the project in broader context.</p> <p>Summary</p> <p>DH and ECDH both establish shared secrets. ECDH typically provides comparable security with smaller keys and improved efficiency.</p>"},{"location":"team/","title":"Team Contribution","text":"Purpose: Document role distribution and accountability for implementation, validation, and documentation work. Member Student ID Core Contributions Shoug Fawaz Abdullah Alomran 223410392 Validation integration, <code>Main</code> flow, <code>Helpers</code>, testing flow design, report assembly, MkDocs site integration. Fai Mohammad Bin Khanjar 223410071 Key-generation logic, shared-secret verification, numerical example review, modular arithmetic validation. Aljohara Waleed A Albawardi 223410346 <code>Encryptor</code> implementation, encryption/decryption test scenarios, output screenshot curation. Yara Mutlaq Mohammed Alzamel 223410834 Parameter scaffolding, support utilities, output formatting, workflow documentation support. <p>The team coordinated through Git/GitHub and iteratively refined validation and output consistency.</p>"},{"location":"code/encryptor/","title":"Encryptor.java","text":"Purpose: Implement shared-key-derived encryption and decryption routines for message flow validation. <pre><code>import java.math.BigInteger;\nimport java.util.Base64;\nimport java.security.MessageDigest;\nimport java.nio.charset.StandardCharsets;\n\npublic class Encryptor {\n\n    private byte[] Key(BigInteger key) throws Exception {\n        MessageDigest msgDigest = MessageDigest.getInstance(\"SHA-256\");\n        byte[] ArrayByte = key.toByteArray();\n        return msgDigest.digest(ArrayByte);\n    }\n\n    private byte[] xor(byte[] data, byte[] key) {\n        byte[] xorArray = new byte[data.length];\n        for (int i = 0; i &lt; data.length; i++) {\n            xorArray[i] = (byte) (data[i] ^ key[i % key.length]);\n        }\n        return xorArray;\n    }\n\n    String encrypt(String msg, BigInteger sharedKey) throws Exception {\n        byte[] msgByte = msg.getBytes(StandardCharsets.UTF_8);\n        byte[] keyByte = Key(sharedKey);\n        byte[] cipherMsgByte = xor(msgByte, keyByte);\n        return Base64.getEncoder().encodeToString(cipherMsgByte);\n    }\n\n    String decrypt(String base64cipherMsg, BigInteger sharedKey) throws Exception {\n        byte[] keyByte = Key(sharedKey);\n        byte[] cipherMsgByte = Base64.getDecoder().decode(base64cipherMsg);\n        byte[] msgByte = xor(cipherMsgByte, keyByte);\n        return new String(msgByte, StandardCharsets.UTF_8);\n    }\n\n    public static void validateMsg(String msg) {\n        if (msg == null) {\n            throw new IllegalArgumentException(\"Message cannot be empty\");\n        }\n    }\n\n    public static void validateCipherMsg(String cipherMsg) {\n        if (cipherMsg == null) {\n            throw new IllegalArgumentException(\"Cipher message cannot be empty\");\n        }\n    }\n}\n</code></pre>"},{"location":"code/helpers/","title":"Helpers.java","text":"Purpose: Provide validated user-input utilities for parameters, keys, and messages. <pre><code>import java.math.BigInteger;\nimport java.security.SecureRandom;\nimport java.util.Scanner;\n\npublic class Helpers {\n\n    public static BigInteger promptPrime(Scanner input) {\n        while (true) {\n            try {\n                System.out.print(\"Enter a prime q (&gt;= 3): \");\n                BigInteger q = new BigInteger(input.nextLine().trim());\n                if (Validator.isPrime(q)) return q;\n                System.out.println(\"That's not a prime number. Try again.\\n\");\n            } catch (Exception e) {\n                System.out.println(\"Invalid input. Please type an integer.\\n\");\n            }\n        }\n    }\n\n    public static BigInteger promptAlpha(Scanner in, BigInteger q) {\n        while (true) {\n            try {\n                System.out.print(\"Enter alpha (1 &lt; alpha &lt; q): \");\n                BigInteger alpha = new BigInteger(in.nextLine().trim());\n                if (Validator.isAlphaInRange(alpha, q)) return alpha;\n                System.out.println(\"Alpha must be &gt; 1 and &lt; q. Try again.\\n\");\n            } catch (Exception e) {\n                System.out.println(\"Invalid input. Please type an integer.\\n\");\n            }\n        }\n    }\n\n    public static BigInteger promptPrivateKey(Scanner input, BigInteger q, String message) {\n        System.out.println(\"\\nPrivate keys must be integers between 1 and q-2 (inclusive).\");\n        BigInteger min = BigInteger.ONE;\n        BigInteger max = q.subtract(BigInteger.TWO);\n        while (true) {\n            try {\n                System.out.print(message);\n                BigInteger x = new BigInteger(input.nextLine().trim());\n                if (x.compareTo(min) &gt;= 0 &amp;&amp; x.compareTo(max) &lt;= 0) return x;\n                System.out.println(\"Invalid range. Please enter a value between 1 and q-2.\\n\");\n            } catch (Exception e) {\n                System.out.println(\"Invalid input. Please type an integer.\\n\");\n            }\n        }\n    }\n\n    public static BigInteger randomPrivateKey(BigInteger q, SecureRandom rnd) {\n        BigInteger min = BigInteger.ONE;\n        BigInteger max = q.subtract(BigInteger.TWO);\n        BigInteger range = max.subtract(min).add(BigInteger.ONE);\n\n        BigInteger r;\n        do {\n            r = new BigInteger(range.bitLength(), rnd);\n        } while (r.compareTo(range) &gt;= 0);\n        return r.add(min);\n    }\n\n    public static String promptMessage(Scanner input) {\n        while (true) {\n            System.out.print(\"Enter a message (&gt; 20 characters): \");\n            String message = input.nextLine();\n            if (Validator.isValidMessage(message)) return message;\n            System.out.println(\"Message too short. Please try again (must be &gt; 20 characters).\\n\");\n        }\n    }\n}\n</code></pre>"},{"location":"code/keyexchange/","title":"KeyExchange.java","text":"Purpose: Define key-pair generation and shared-secret computation for each participant. <pre><code>import java.math.BigInteger;\nimport java.security.SecureRandom;\n\npublic class KeyExchange extends Parameters {\n\n    private SecureRandom random = new SecureRandom();\n\n    private BigInteger privateKey;\n    private BigInteger publicKey;\n\n    public KeyExchange(BigInteger q, BigInteger alpha) {\n        super(q, alpha);\n        generateKeys();\n    }\n\n    private void generateKeys() {\n        this.privateKey = new BigInteger(getQ().bitLength(), random)\n                .mod(getQ().subtract(BigInteger.TWO))\n                .add(BigInteger.ONE);\n\n        this.publicKey = getAlpha().modPow(privateKey, getQ());\n    }\n\n    public BigInteger computeSharedKey(BigInteger otherPublic) {\n        return otherPublic.modPow(privateKey, getQ());\n    }\n\n    public BigInteger getPrivateKey() {\n        return privateKey;\n    }\n\n    public BigInteger getPublicKey() {\n        return publicKey;\n    }\n}\n</code></pre>"},{"location":"code/main/","title":"Main.java","text":"Purpose: Show the main execution flow, mode handling, and end-to-end orchestration logic. <pre><code>import java.math.BigInteger;\nimport java.security.SecureRandom;\nimport java.util.Scanner;\n\npublic class Main {\n\n    private static final SecureRandom random = new SecureRandom();\n\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n\n        System.out.println(\"--- Royal Convoy - Secure Communication (Diffie-Hellman / ECDH Demo) ---\");\n        System.out.println(\"This program demonstrates how the control center and vehicles exchange keys securely.\\n\");\n\n        while (true) {\n            System.out.println(\"MAIN MENU:\");\n            System.out.println(\"1) Numerical Example (Section 1.3 demo - fixed values)\");\n            System.out.println(\"2) Numerical Example (auto-generated values)\");\n            System.out.println(\"3) Live Mode (manual / auto parameters and private keys)\");\n            System.out.println(\"0) Exit\");\n            System.out.print(\"Choose an option: \");\n\n            String choice = input.nextLine().trim();\n\n            switch (choice) {\n                case \"1\" -&gt; runFixedExample();\n                case \"2\" -&gt; runRandomExample(input);\n                case \"3\" -&gt; runLiveMode(input);\n                case \"0\" -&gt; {\n                    System.out.println(\"Goodbye!\");\n                    input.close();\n                    return;\n                }\n                default -&gt; System.out.println(\"Invalid choice. Please enter 1, 2, 3, or 0.\\n\");\n            }\n        }\n    }\n\n    private static void runFixedExample() {\n        System.out.println(\"\\n--- Numerical Example (Section 1.3 - Fixed) ---\");\n\n        BigInteger q = BigInteger.valueOf(23);\n        BigInteger alpha = BigInteger.valueOf(5);\n        Parameters storage = new Parameters(q, alpha);\n\n        BigInteger Xa = BigInteger.valueOf(6);\n        BigInteger Xb = BigInteger.valueOf(15);\n\n        BigInteger Ya = alpha.modPow(Xa, q);\n        BigInteger Yb = alpha.modPow(Xb, q);\n        BigInteger kA = Yb.modPow(Xa, q);\n        BigInteger kB = Ya.modPow(Xb, q);\n\n        System.out.println(\"To give an example, both 2 cars and the control center need a safe way to communicate.\");\n        System.out.println(storage);\n        System.out.println(\"Car 1 chooses Xa = 6 \u2192 Ya = 5^6 mod 23 = \" + Ya);\n        System.out.println(\"Car 2 chooses Xb = 15 \u2192 Yb = 5^15 mod 23 = \" + Yb);\n        System.out.println(\"Each car computes the shared key:\");\n        System.out.println(\"Car 1: 19^6 mod 23 = \" + kA);\n        System.out.println(\"Car 2: 8^15 mod 23 = \" + kB);\n        System.out.println(\"Both cars share the same key: \" + kA + \"\\n\");\n\n        String message = \"Royal convoy message remains secure through shared key exchange.\";\n        System.out.println(\"Example message: \" + message);\n\n        try {\n            Encryptor enc = new Encryptor();\n            String cipher = enc.encrypt(message, kA);\n            String plain = enc.decrypt(cipher, kB);\n            System.out.println(\"Encrypted Message = \" + cipher);\n            System.out.println(\"Decrypted Message = \" + plain);\n            System.out.println(\"Decryption OK = \" + plain.equals(message) + \"\\n\");\n        } catch (Exception e) {\n            System.out.println(\"Encryption/Decryption failed: \" + e.getMessage());\n        }\n    }\n\n    private static void runRandomExample(Scanner input) {\n        System.out.println(\"\\n--- Numerical Example (Auto-generated values) ---\");\n\n        BigInteger q = BigInteger.probablePrime(8, random);\n        BigInteger alpha = BigInteger.valueOf(random.nextInt(3, q.intValue() - 1));\n        Parameters storage = new Parameters(q, alpha);\n\n        BigInteger Xa = BigInteger.valueOf(random.nextInt(2, q.intValue() - 2));\n        BigInteger Xb = BigInteger.valueOf(random.nextInt(2, q.intValue() - 2));\n\n        BigInteger Ya = alpha.modPow(Xa, q);\n        BigInteger Yb = alpha.modPow(Xb, q);\n        BigInteger kA = Yb.modPow(Xa, q);\n        BigInteger kB = Ya.modPow(Xb, q);\n\n        System.out.println(\"Automatically generated example parameters and results:\");\n        System.out.println(storage);\n        System.out.println(\"Car 1 (Xa): \" + Xa + \" --&gt; Ya = \" + Ya);\n        System.out.println(\"Car 2 (Xb): \" + Xb + \" --&gt; Yb = \" + Yb);\n        System.out.println(\"Shared key for Car 1: \" + kA);\n        System.out.println(\"Shared key for Car 2: \" + kB);\n        System.out.println(\"Keys match: \" + kA.equals(kB) + \"\\n\");\n\n        String message = Helpers.promptMessage(input);\n\n        try {\n            Encryptor enc = new Encryptor();\n            String cipher = enc.encrypt(message, kA);\n            String plain = enc.decrypt(cipher, kB);\n            System.out.println(\"--- Encryption Test ---\");\n            System.out.println(\"Original Message  = \" + message);\n            System.out.println(\"Encrypted Message = \" + cipher);\n            System.out.println(\"Decrypted Message = \" + plain);\n            System.out.println(\"Decryption OK = \" + plain.equals(message) + \"\\n\");\n        } catch (Exception e) {\n            System.out.println(\"Encryption/Decryption failed: \" + e.getMessage());\n        }\n    }\n\n    private static void runLiveMode(Scanner input) {\n        System.out.println(\"\\n--- Live Mode ---\");\n        System.out.println(\"You can either enter your own values for q and alpha, or let the program generate them.\\n\");\n\n        System.out.println(\"Choose parameter mode:\");\n        System.out.println(\"a) Auto-generate q and alpha\");\n        System.out.println(\"b) Enter manually\");\n        System.out.print(\"Your choice (a/b): \");\n        String paramChoice = input.nextLine().trim().toLowerCase();\n\n        BigInteger q, alpha;\n\n        if (\"b\".equals(paramChoice)) {\n            q = Helpers.promptPrime(input);\n            alpha = Helpers.promptAlpha(input, q);\n        } else {\n            q = BigInteger.probablePrime(8, random);\n            alpha = BigInteger.valueOf(random.nextInt(3, q.intValue() - 1));\n            System.out.println(\"Automatically generated parameters:\");\n            System.out.println(\"q = \" + q + \", alpha = \" + alpha + \"\\n\");\n        }\n\n        Parameters storage = new Parameters(q, alpha);\n        System.out.println(storage + \"\\n\");\n\n        System.out.println(\"Choose private-key mode:\");\n        System.out.println(\"a) Auto-generate private keys\");\n        System.out.println(\"b) Enter private keys manually\");\n        System.out.print(\"Your choice (a/b): \");\n        String keyChoice = input.nextLine().trim().toLowerCase();\n\n        BigInteger Xa, Xb;\n        if (\"b\".equals(keyChoice)) {\n            Xa = Helpers.promptPrivateKey(input, q, \"Enter private key for Car 1: \");\n            Xb = Helpers.promptPrivateKey(input, q, \"Enter private key for Car 2: \");\n        } else {\n            Xa = BigInteger.valueOf(random.nextInt(2, q.intValue() - 2));\n            Xb = BigInteger.valueOf(random.nextInt(2, q.intValue() - 2));\n            System.out.println(\"Auto private keys generated: Xa = \" + Xa + \", Xb = \" + Xb + \"\\n\");\n        }\n\n        BigInteger Ya = alpha.modPow(Xa, q);\n        BigInteger Yb = alpha.modPow(Xb, q);\n        BigInteger kA = Yb.modPow(Xa, q);\n        BigInteger kB = Ya.modPow(Xb, q);\n\n        if (!kA.equals(kB)) {\n            System.out.println(\"Shared keys do not match. Please try again.\\n\");\n            return;\n        }\n\n        String message = Helpers.promptMessage(input);\n\n        try {\n            Encryptor enc = new Encryptor();\n            String cipher = enc.encrypt(message, kA);\n            String plain = enc.decrypt(cipher, kB);\n\n            System.out.println(\"\\n--- RESULTS ---\");\n            System.out.println(\"q = \" + q);\n            System.out.println(\"alpha = \" + alpha);\n            System.out.println(\"Xa = \" + Xa);\n            System.out.println(\"Xb = \" + Xb);\n            System.out.println(\"Ya = \" + Ya);\n            System.out.println(\"Yb = \" + Yb);\n            System.out.println(\"Shared key = \" + kA);\n            System.out.println(\"Original Message = \" + message);\n            System.out.println(\"Encrypted Message = \" + cipher);\n            System.out.println(\"Decrypted Message = \" + plain);\n            System.out.println(\"Decryption OK = \" + plain.equals(message));\n            System.out.println(\"Secure session established between convoy vehicles and control center.\\n\");\n\n        } catch (Exception e) {\n            System.out.println(\"Encryption/Decryption failed: \" + e.getMessage());\n        }\n    }\n}\n</code></pre>"},{"location":"code/parameters/","title":"Parameters.java","text":"Purpose: Store and expose the public Diffie-Hellman parameters used by all participants. <pre><code>import java.math.BigInteger;\n\npublic class Parameters {\n\n    private BigInteger q;\n    private BigInteger alpha;\n\n    public Parameters(BigInteger q, BigInteger alpha) {\n        this.q = q;\n        this.alpha = alpha;\n    }\n\n    public BigInteger getQ() {\n        return q;\n    }\n\n    public BigInteger getAlpha() {\n        return alpha;\n    }\n\n    @Override\n    public String toString() {\n        return \"Public Parameters:\\n\" +\n               \"Prime number (q): \" + q + \"\\n\" +\n               \"Primitive root (alpha): \" + alpha;\n    }\n}\n</code></pre>"},{"location":"code/utils/","title":"Utils.java","text":"Purpose: Supply helper routines for random values, display formatting, and key-byte normalization. <pre><code>import java.math.BigInteger;\nimport java.security.SecureRandom;\n\npublic class Utils {\n\n    private static final SecureRandom secureRandom = new SecureRandom();\n\n    public static BigInteger getRandom(BigInteger upperLimit) {\n        BigInteger result;\n        do {\n            result = new BigInteger(upperLimit.bitLength(), secureRandom);\n        } while (result.compareTo(BigInteger.ONE) &lt; 0 || result.compareTo(upperLimit) &gt;= 0);\n        return result;\n    }\n\n    public static void printLine(String label, Object value) {\n        System.out.println(label + \": \" + value);\n    }\n\n    public static byte[] normalizeKeyBytes(BigInteger key) {\n        byte[] bytes = key.toByteArray();\n        if (bytes.length &gt; 1 &amp;&amp; bytes[0] == 0) {\n            byte[] normalized = new byte[bytes.length - 1];\n            System.arraycopy(bytes, 1, normalized, 0, normalized.length);\n            return normalized;\n        }\n        return bytes;\n    }\n}\n</code></pre>"},{"location":"code/validator/","title":"Validator.java","text":"Purpose: Centralize mathematical and input validation rules required by the key-exchange flow. <pre><code>import java.math.BigInteger;\n\n/**\n * Minimal Validator class for validating prime numbers, alpha values,\n * and message lengths used in the Diffie-Hellman key exchange system.\n */\npublic class Validator {\n\n    public static boolean isPrime(BigInteger q) {\n        if (q == null) return false;\n        if (q.compareTo(BigInteger.valueOf(3)) &lt; 0) return false;\n        return q.isProbablePrime(100);\n    }\n\n    public static boolean isAlphaInRange(BigInteger alpha, BigInteger q) {\n        return alpha != null &amp;&amp; q != null\n                &amp;&amp; alpha.compareTo(BigInteger.ONE) &gt; 0\n                &amp;&amp; alpha.compareTo(q) &lt; 0;\n    }\n\n    public static boolean isValidMessage(String message) {\n        return message != null &amp;&amp; message.trim().length() &gt; 20;\n    }\n}\n</code></pre>"},{"location":"report/report/","title":"Project Report","text":"Purpose: Provide direct access to the final submitted report in embedded and standalone form. <p>Use one of the following options:</p> <ul> <li>Open report in new tab</li> <li>Download report (HTML)</li> </ul>"}]}